# **FlawedAmmyy analysis**

## General info


|File name|swaqp.exe|
| - | - |
|SHA256|FFCD75ED74E0322C6A2712B539830EFF2575F990A4D54D3C49FF14349EA6472F|

This version of FlawedAmmyy was used during TA505 group campaign in late 2019. It appears to be a downloader for other stages of their attacks.

It checks the existence of `twein.dll` which is  another campaign malware then downloads a malicious driver and a Bot. It also gathers system info that includes a list of installed software and drivers identifying signed ones and send it to C2 servers. It’ll also try to connect to C2 every 16 hours in case it was needed to “update” the dropped Bot.

## Unpacking

Loading it up on DiE and PEStudio doesn’t give us much, trying to disassemble it you’ll get a good indicator that it’s packed with some custom packing routine, that is of course TA505 unique packer.

We can try unpacking it in a couple different ways..

An unpacking routine usually has 2 common ways to return execution to the unpacked executable : 

- It can store the entry point of the unpacked executable in a register then calls it.. Like  `call edx`
- It can use a `ret` instruction, It’ll return to the address on top of the stack

So we can simply look at the bottom of a subroutine for one of those calls or return instructions and set a breakpoint on it, follow it in dump then extract the unpacked executable

Honestly that’s too much work and I’m not interested in reversing the unpacking routine this time. However you can read more about it [here](https://www.ptsecurity.com/ww-en/analytics/pt-esc-threat-intelligence/operation-ta505/).

We can just set a breakpoint on `VirtualAlloc` and `VirtualProtect` as I noticed it imports those anyways, follow it in dump and extract it

And there’s of course the easy way of just uploading it on UnpacMe. It's a pretty good tool but I’m not that lazy AND I don’t really recommend using it during a “real investigation” as you wouldn’t want to share it publicly just yet.

Anyways, firing up our debugger, setting breakpoints on  `VirtualAlloc` and `VirtualProtect`, once you hit `VirtualProtect` you’ll find the unpacked executable in the memory dump.

![https://lh5.googleusercontent.com/D\_XBWJ7lW6WrmUosgJqSRtNzj8AdhVjtYXMhle7HF\_XxLC6zsmXY6cr1jqECCg0aU2eU3x5xHqO7tvrgrCocivOCvfMDmcgqmHTbl7hUaUxtOW2Gg3FpcGFcsSEUyxiMLv4D4Uv66CALz3vCzOcV0w](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.001.png)

You can make sure It’s not the packed one writing itself into memory by simply loading the packed one into a hex editor and comparing the two. All we have to do now is to dump it, we don’t need to unmap it from memory or fix any imports as it is not executed yet.

## Basic Static

We successfully unpacked the payload and it’s quite interesting, good thing for us it’s not trying to hide API calls or strings. Also the timestamp is June 2019, So it looks like this sample was used during or a little after their 2019 campaign.

## Basic Dynamic/Behavioral

I guess FlawedAmmyy is doing all the work for us.. It actually logs all its actions and results in a `log.txt` that is later on sent over to its C2 after sending 3 more files: `sinfo.txt` containing system info 

![https://lh3.googleusercontent.com/ZcmA07ei6s9oDpgG9irGrurgijIwDJGKPYoOh4V9hOYWm3TuOR\_LFk5upTWMaBT8EkSgB2jQaPip0W8G4lEqOU1OjHEdPRpCaCDXm8s0TsubybvERM77pFqQNMicaGwLdYoM2ChpQ2F9dxUJmi3J2g](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.002.png)

`soft.txt` containing installed software

![https://lh5.googleusercontent.com/gMDwibu180AYpNZgxeVMqglCw-2D6oDsXXdBGd0\_QQiXmc0OqRzD9iAEl5VyYpOH5TATGMHC\_w54VaF8\_jsFFcsq5KgbkN84olfMSSYOUcf5yTiKkImLLJ0VsOTTXNfFviHdKEsO5YXBr6\_eyJFFYA](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.003.png)

`Signs.txt` containing singed software

![https://lh6.googleusercontent.com/Lz0xJx97E6xpGqntCxKJsDP\_TMf7eGbvzuCDcJ1BC7stIXSyjn94fNuv8v9\_HB\_TAe4AbZLFZGh0WyL5g8V5izK7Aiz6cZJEJtucu2OIyzhvOzk8yByCilH7-ZZBAA4TW6FC4GAclH0zHVcxM2mrQw](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.004.png)

The `log.txt` file can be captured via any network sniffer instead of debugging or terminating the execution. I used fiddler. It's a pretty neat tool.

![https://lh3.googleusercontent.com/5VE-BApd--7SkNpnkaaXxDBvU8KU4F7f9O5k1qlVItmrwcZ7ACSFoWzlhWKmD9YYGUR6E7Zyw-KLRoFhC8b3MAEOgDsmYlCGBZOdZeo00A--\_x1HPRPRUIkvnvG-AThF\_AWbrcxt1L7nNB1cFUX3dw](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.005.png)

It also adds two registry keys 

`HKLM\SOFTWARE\7-Zip\99`

`HKLM\SOFTWARE\7-Zip\Path32`

Adds a file 

`C:\Windows\Logs\diag`

And eventually deleting itself. Let’s fire up IDA and take a look under the hood.

## Deep Analysis

The unpacked payload is pretty straight forward, it starts by checking for McAfee processes `ModuleCoreService.exe`, `mcapexe.exe` and `McPvTray.exe` if none is found it continues to create the log file and write the debug string `running loader` into it then check for the OS version, it will exit if its running on Windows Server 2008 or earlier. So it's targeting Windows server 2008 R2 and Windows 7 or higher.

If it infects a system that is not targeting, it will start its Uninstall routine.

So here how it works, if a McAfee process is present it will exit immediately otherwise it proceeds to gather system info: 

![](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.006.png)

It will create a new process and push `systeminfo` as a command line argument then saves the output to `sinfo.txt` and `wmic product get name,version` which will list all installed applications on the machine and saves its output to `soft.txt`.

It will also parse installed applications in the program files, program files (x86) and System32\drivers directories, it will pass all that into a another subroutine that actually formats the data and saves it in `signs.txt` as in `signed software` and if it’s a signed driver it writes it to `avs.txt`

It will then sleep for 10 seconds before sending the `log.txt` to `45.227.252.54` along with the collected data stored in previously mentioned text files. Then it deletes the text files it created and writes a `setup.bat` in the temp directory with a powershell command to delete itself from the system and remove its trace from the system. 

![https://lh3.googleusercontent.com/d5JYJex4xD5zoMI4yuu0647B5EnPS7ngUnLLrK069odi9HTVugcQO0EAIv03ugPU0AyNI7dEBTDcEW6NE-i6ElHEVNBqIAAtf7AjpKRH2nlEhm4QvhbFqGX\_e\_s8VNKQOYYWf\_98wIEmxsW8YNM4aA](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.007.png)

![https://lh4.googleusercontent.com/dqBaOTVs77S1BB2yZnNBFhWhBkalBzfTlTYmY36FvRve-5vqRTb-8yprhhkl81Uiq-Rf0p5HWzqtiZgbqBtU8gwm\_GNHGtiwLy6yy5EACiz5XTEjlHwHTHBl8a1g1xOrWk9lXaDgQRGwaK5-H16DIw](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.008.png)


Back to our normal flow… It also runs a keyboard layout check and proceeds to the uninstall routine adding a `cis found` text to the log if it’s running on certain layouts

![https://lh5.googleusercontent.com/AEUsjtikpyrtIqoAFCn--il2B2foAJ\_2YNvcxpcdKtZ5M-W2bul20kF\_Qr6TyLxiPgJnu820KmW3pjwNBPndqlk7UvGosVlhRvfmZFwUhL3dr0d5MGnzcYeEPLRc-Wz\_j3f6GEG0jZk6HH3L3uMuqg](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.009.png)

Using a simple python script and some help from MSDN we find it ignores the following:


|**Keyboard**|**Keyboard identifier**|**Keyboard**|**Keyboard identifier**|
| :- | :- | :- | :- |
|Armenian Eastern (Legacy)|0x0000042b|Kazakh|0x0000043f|
|Armenian Phonetic|0x0002042b|Kyrgyz Cyrillic|0x00000440|
|Armenian Typewriter|0x0003042b|Romanian (Legacy)|0x00000418|
|Armenian Western|0x0001042b|Romanian (Programmers)|0x00020418|
|Azerbaijani (Standard)|0x0001042c|Romanian (Standard)|0x00010418|
|Azerbaijani Cyrillic|0x0000082c|Russian|0x00000419|
|Azerbaijani Latin|0x0000042c|Russian (Typewriter)|0x00010419|
|Belarusian|0x00000423|Russian - Mnemonic|0x00020419|
|Georgian (Ergonomic)|0x00020437|Tajik|0x00000428|
|Georgian (Legacy)|0x00000437|Turkmen|0x00000442|
|Georgian (MES)|0x00030437|Ukrainian|0x00000422|
|Georgian (Old Alphabets)|0x00040437|Ukrainian (Enhanced)|0x00020422|
|Georgian (QWERTY)|0x00010437|Uzbek Cyrillic|0x00000843|

It checks if it’s already running by creating its mutex `Global\\system32\_mutant\_service` if it already exists it will exit.

Moving to an interesting part here where it checks for `crypt32.dll`  version and downloads it if its Build Number or Revision Number is less than `7601` and `18741` respectively by connecting to a C&C getting the file according to the windows version

![](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.010.png)

Here is a list of IPs it downloads the dll from:

- `hxxp://45.227.252.54`

- `hxxp://139.60.160.6`

- `hxxp://185.55.243.15`

- `hxxp://92.223.73.11`

So for example the built ulr should be like this : `hxxp://45.227.252.54/1.php?f=3&lip=127.0.0.1`

It downloads the dll in the temp folder and runs a powershell command as admin to install it

![](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.011.png)

But why does it do that tho? Well, after some searching, turns out that installing the update ends support for `SHA-1` code signing certifications, requiring `SHA-2` instead so it’s most likely for their signed payloads to work properly on non-updated systems.

FlawedAmmyy also tries to get the infected system's public/external IP address by connecting to `http://myexternalip.com/raw`, `http://ipecho.net/plain`, `http://ifconfig.me/ip` if that didn't work, it collects the system's adapter info and saves the NAT status in a registry key it creates in `HKEY\_LOCAL\_MACHINE\\Software\\7-Zip\\99` containing either 0 or 1 indicating NAT is either OFF or ON.

After that, It will create `C:\Windows\Logs\diag` directory and launch a thread monitoring the changes in the directory and send it to C2 `45.227.252.54`. It will also add a `22800C` named value to `HKEY\_LOCAL\_MACHINE\SYSTEM`.

![](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.012.png)

It will then try to check if a “rootkit” is installed by trying to access `HKEY\_LOCAL\_MACHINE\SYSTEM` value name `22C008` so it will only work if the rootkit is already present, if the rootkit is not there the sample will remove `twein\_64.dll` and `twein\_64.dll` from the windows directory. (“Twein” was actually a part of previous TA505 malware) and proceeds to download a malicious driver from one of their C2 in addition to another Bot. The bot will be downloaded whether or not the rootkit is present tho.

Both routines for downloading the bot/driver are pretty much the same. It starts by generating a random RC4 key and base64 encode it and saves it in `HKEY\_LOCAL\_MACHINE\SOFTWARE\7-Zip` in `Path32` key then generates the victim ID or bot ID by pushing the hardcoded text `tDAZRN9ojq5aga999` into couple encryption routines with a character indicator of a success/fail state for calling `GetSystemWow64DirectoryA` API, so it would eventually be something like this:

![](Aspose.Words.21d5d69b-6003-4103-96a7-51817d5dc431.013.png)
Next, it queries `SYSTEM\CurrentControlSet\Control\Class\{4D36E968-E325-11CE-BFC1-08002BE10318}\0000` to get `DriverDesc` value which is the GPU name and it will loop through making sure it’s only letters/numbers replacing the whitespace with `-`, it does the same for the computer name, workgroup name and the product name (queried from `SOFTWARE\Microsoft\Windows NT\CurrentVersion`). 

It then maps all that into a JSON object as we saw in the captured network packet and encoded with the key `gJypA9RWUlYpnBbzujVqE6fDcEAk0zoz` then base64 encode it before sending it.

It will then go through the C2 list until it successfully downloads the payload and of course checks for the `mz` header before proceeding to the installation.

The installation process depends if the payload is a bot or driver.

So if it’s a Bot download routine it will install the bot by trying to create one of the following vale names in `HKEY\_LOCAL\_MACHINE\SYSTEM` registry `22402C` or `228028` then call `Wow64DisableWow64FsRedirection` API and logs the installation status.

If it’s a driver installation routines, It will start by calling `Wow64DisableWow64FsRedirection` using `GetModuleHandleW` and `GetProcAddress` and proceeds to writing the payload to a `.sys` file in the drivers directory and create the service as a driver service using `SERVICE\_KERNEL\_DRIVER` flag and start it.

Additionally it will create a named value `228050` in `HKEY\_LOCAL\_MACHINE\SYSTEM` holding a hardcoded blacklisted executables such as `blinksvc.exe`, `processhacker-2.39-setup.exe`, `AAV\_Guard.exe`. 

And `228078` for blacklisted signers such as `Kaspersky Lab`, `BITDEFENDER LLC`

And `2280A0` for blacklisted drivers like `DarkSpy`, `Process Monitor Driver`.

If any error occurs during the driver installation it will log the error message then delete the driver/payload.

If the driver and Bot installation is successfully done, it will sleep for 1000 minutes then connects to C2 servers checking for Bot updates.


## IOCs


|IOC|IOC Type|Description|
| :- | :- | :- |
|hxxp://45.227.252.54|URL|FlawedAmmyy C2|
|<p>hxxp://139.60.160.6</p><p></p>|URL|Payload C2|
|<p>hxxp://185.55.243.15</p><p></p>|URL|Payload C2|
|<p>hxxp://92.223.73.11</p><p></p>|URL|Payload C2|
|<p>C:\Windows\Logs\diag</p><p></p>|Directory|Logs changes in the directory|
|<p>log.txt</p><p></p>|File|Logs FlawedAmmyy actions|
|sinfo.txt|File|Contains gathered system info|
|<p>soft.txt</p><p></p>|File|Contains gathered installed application names|
|<p>signs.txt</p><p></p>|File|Contains gathered signed software|
|<p>{HKEY\_LOCAL\_MACHINE\SYSTEM}\22800C</p><p></p>|Registry Key|FlawedAmmyy payload key|
|<p>{HKEY\_LOCAL\_MACHINE\SYSTEM}\228050</p><p></p>|Registry Key|FlawedAmmyy blacklisted executables|
|<p>{HKEY\_LOCAL\_MACHINE\SYSTEM}\228078</p><p></p>|Registry Key|FlawedAmmyy blacklisted signers|
|<p>{HKEY\_LOCAL\_MACHINE\SYSTEM}\2280A0</p><p></p>|Registry Key|FlawedAmmyy blacklisted drivers|
|<p>HKEY\_LOCAL\_MACHINE\SOFTWARE\7-Zip\Path32</p><p></p>|Registry Key|Holds bace64 encoded RC4 key value|
|<p>HKEY\_LOCAL\_MACHINE\SOFTWARE\7-Zip\99</p><p></p>|Registry Key|NAT on/off indicator|
|Global\system32\_mutant\_service|Mutex|FlawedAmmyy mutex|

## MITRE – Techniques Used


|ID|Name|Use|
| :- | :- | :- |
|T1071	.001|Application Layer Protocol: Web Protocols|FlawedAmmyy has used HTTP for C2|
|T1059	.001|Command and Scripting Interpreter: PowerShell|FlawedAmmyy has used PowerShell to execute commands|
|T1059	.003|Command and Scripting Interpreter: Windows Command Shell|FlawedAmmyy has used cmd to execute commands on a compromised host|
|T1005|Data from Local System|FlawedAmmyy has collected information from a compromised machine|
|T1041|Exfiltration Over C2 Channel|FlawedAmmyy has sent data collected from a compromised host to its C2 servers|
|T1070	.004|Indicator Removal: File Deletion|FlawedAmmyy can execute batch scripts to delete files|
|T1518	.001|Software Discovery: Security Software Discovery|<p>FlawedAmmyy will attempt to detect anti-virus products during the initial infection</p><p>	</p>|
|T1082|System Information Discovery|FlawedAmmyy can collect the victim's operating system and computer name during the initial infection.|
|T1033|System Owner/User Discovery|FlawedAmmyy enumerates the current user during the initial infection|
|T1047|Windows Management Instrumentation|FlawedAmmyy leverages WMI to enumerate anti-virus on the victim|







